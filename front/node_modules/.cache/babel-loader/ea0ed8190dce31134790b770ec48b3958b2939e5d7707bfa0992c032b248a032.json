{"ast":null,"code":"function _writeStringToArray(aString, targetArray, offset) {\n  for (let i = 0; i < aString.length; ++i) targetArray[offset + i] = aString.charCodeAt(i);\n}\nfunction _writeInt16ToArray(aNumber, targetArray, offset) {\n  aNumber = Math.floor(aNumber);\n  targetArray[offset + 0] = aNumber & 255; // byte 1\n  targetArray[offset + 1] = aNumber >> 8 & 255; // byte 2\n}\nfunction _writeInt32ToArray(aNumber, targetArray, offset) {\n  aNumber = Math.floor(aNumber);\n  targetArray[offset + 0] = aNumber & 255; // byte 1\n  targetArray[offset + 1] = aNumber >> 8 & 255; // byte 2\n  targetArray[offset + 2] = aNumber >> 16 & 255; // byte 3\n  targetArray[offset + 3] = aNumber >> 24 & 255; // byte 4\n}\n\n// Return the bits of the float as a 32-bit integer value.  This\n// produces the raw bits; no intepretation of the value is done.\nfunction _floatBits(f) {\n  const buf = new ArrayBuffer(4);\n  new Float32Array(buf)[0] = f;\n  const bits = new Uint32Array(buf)[0];\n  // Return as a signed integer.\n  return bits | 0;\n}\nfunction _writeAudioBufferToArray(audioBuffer, targetArray, offset, bitDepth) {\n  let index = 0,\n    channel = 0;\n  const length = audioBuffer.length;\n  const channels = audioBuffer.numberOfChannels;\n  let channelData, sample;\n\n  // Clamping samples onto the 16-bit resolution.\n  for (index = 0; index < length; ++index) {\n    for (channel = 0; channel < channels; ++channel) {\n      channelData = audioBuffer.getChannelData(channel);\n\n      // Branches upon the requested bit depth\n      if (bitDepth === 16) {\n        sample = channelData[index] * 32768.0;\n        if (sample < -32768) sample = -32768;else if (sample > 32767) sample = 32767;\n        _writeInt16ToArray(sample, targetArray, offset);\n        offset += 2;\n      } else if (bitDepth === 32) {\n        // This assumes we're going to out 32-float, not 32-bit linear.\n        sample = _floatBits(channelData[index]);\n        _writeInt32ToArray(sample, targetArray, offset);\n        offset += 4;\n      } else {\n        console.log('Invalid bit depth for PCM encoding.');\n        return;\n      }\n    }\n  }\n}\n\n// Converts the Blob data to AudioBuffer\nasync function _getAudioBuffer(blobData, contextOptions = undefined) {\n  let blob = blobData;\n  if (!(blob instanceof Blob)) blob = new Blob([blobData]);\n  const url = URL.createObjectURL(blob);\n  const response = await fetch(url);\n  const arrayBuffer = await response.arrayBuffer();\n  const audioContext = new AudioContext(contextOptions);\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  return audioBuffer;\n}\n\n/**\r\n * \r\n * @param {Blob | Blob[]} blobData - Blob or Blob[] to be converted to audio/wave Blob\r\n * @param {boolean} as32BitFloat - Convert to 16-bit or 32-bit file, default 16-bit\r\n * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n * @returns \r\n */\nasync function getWaveBlob(blobData, as32BitFloat, contextOptions = undefined) {\n  const audioBuffer = await _getAudioBuffer(blobData, contextOptions);\n\n  // Encoding setup.\n  const frameLength = audioBuffer.length;\n  const numberOfChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const bitsPerSample = as32BitFloat ? 32 : 16;\n  const bytesPerSample = bitsPerSample / 8;\n  const byteRate = sampleRate * numberOfChannels * bitsPerSample / 8;\n  const blockAlign = numberOfChannels * bitsPerSample / 8;\n  const wavDataByteLength = frameLength * numberOfChannels * bytesPerSample;\n  const headerByteLength = 44;\n  const totalLength = headerByteLength + wavDataByteLength;\n  const waveFileData = new Uint8Array(totalLength);\n  const subChunk1Size = 16;\n  const subChunk2Size = wavDataByteLength;\n  const chunkSize = 4 + (8 + subChunk1Size) + (8 + subChunk2Size);\n  _writeStringToArray('RIFF', waveFileData, 0);\n  _writeInt32ToArray(chunkSize, waveFileData, 4);\n  _writeStringToArray('WAVE', waveFileData, 8);\n  _writeStringToArray('fmt ', waveFileData, 12);\n\n  // SubChunk1Size (4)\n  _writeInt32ToArray(subChunk1Size, waveFileData, 16);\n  // AudioFormat (2): 3 means 32-bit float, 1 means integer PCM.\n  _writeInt16ToArray(as32BitFloat ? 3 : 1, waveFileData, 20);\n  // NumChannels (2)\n  _writeInt16ToArray(numberOfChannels, waveFileData, 22);\n  // SampleRate (4)\n  _writeInt32ToArray(sampleRate, waveFileData, 24);\n  // ByteRate (4)\n  _writeInt32ToArray(byteRate, waveFileData, 28);\n  // BlockAlign (2)\n  _writeInt16ToArray(blockAlign, waveFileData, 32);\n  // BitsPerSample (4)\n  _writeInt32ToArray(bitsPerSample, waveFileData, 34);\n  _writeStringToArray('data', waveFileData, 36);\n  // SubChunk2Size (4)\n  _writeInt32ToArray(subChunk2Size, waveFileData, 40);\n\n  // Write actual audio data starting at offset 44.\n  _writeAudioBufferToArray(audioBuffer, waveFileData, 44, bitsPerSample);\n  return new Blob([waveFileData], {\n    type: 'audio/wave'\n  });\n}\nmodule.exports = getWaveBlob;","map":{"version":3,"names":["_writeStringToArray","aString","targetArray","offset","i","length","charCodeAt","_writeInt16ToArray","aNumber","Math","floor","_writeInt32ToArray","_floatBits","f","buf","ArrayBuffer","Float32Array","bits","Uint32Array","_writeAudioBufferToArray","audioBuffer","bitDepth","index","channel","channels","numberOfChannels","channelData","sample","getChannelData","console","log","_getAudioBuffer","blobData","contextOptions","undefined","blob","Blob","url","URL","createObjectURL","response","fetch","arrayBuffer","audioContext","AudioContext","decodeAudioData","getWaveBlob","as32BitFloat","frameLength","sampleRate","bitsPerSample","bytesPerSample","byteRate","blockAlign","wavDataByteLength","headerByteLength","totalLength","waveFileData","Uint8Array","subChunk1Size","subChunk2Size","chunkSize","type","module","exports"],"sources":["C:/Users/aayza/OneDrive/Рабочий стол/diplom/front/node_modules/webm-to-wav-converter/wavBlobUtil.js"],"sourcesContent":["function _writeStringToArray(aString, targetArray, offset) {\r\n    for (let i = 0; i < aString.length; ++i)\r\n        targetArray[offset + i] = aString.charCodeAt(i);\r\n}\r\n\r\nfunction _writeInt16ToArray(aNumber, targetArray, offset) {\r\n    aNumber = Math.floor(aNumber);\r\n    targetArray[offset + 0] = aNumber & 255;          // byte 1\r\n    targetArray[offset + 1] = (aNumber >> 8) & 255;   // byte 2\r\n}\r\n\r\nfunction _writeInt32ToArray(aNumber, targetArray, offset) {\r\n    aNumber = Math.floor(aNumber);\r\n    targetArray[offset + 0] = aNumber & 255;          // byte 1\r\n    targetArray[offset + 1] = (aNumber >> 8) & 255;   // byte 2\r\n    targetArray[offset + 2] = (aNumber >> 16) & 255;  // byte 3\r\n    targetArray[offset + 3] = (aNumber >> 24) & 255;  // byte 4\r\n}\r\n\r\n// Return the bits of the float as a 32-bit integer value.  This\r\n// produces the raw bits; no intepretation of the value is done.\r\nfunction _floatBits(f) {\r\n    const buf = new ArrayBuffer(4);\r\n    (new Float32Array(buf))[0] = f;\r\n    const bits = (new Uint32Array(buf))[0];\r\n    // Return as a signed integer.\r\n    return bits | 0;\r\n}\r\n\r\nfunction _writeAudioBufferToArray(\r\n    audioBuffer,\r\n    targetArray,\r\n    offset,\r\n    bitDepth\r\n) {\r\n    let index = 0, channel = 0;\r\n    const length = audioBuffer.length;\r\n    const channels = audioBuffer.numberOfChannels;\r\n    let channelData, sample;\r\n\r\n    // Clamping samples onto the 16-bit resolution.\r\n    for (index = 0; index < length; ++index) {\r\n        for (channel = 0; channel < channels; ++channel) {\r\n            channelData = audioBuffer.getChannelData(channel);\r\n\r\n            // Branches upon the requested bit depth\r\n            if (bitDepth === 16) {\r\n                sample = channelData[index] * 32768.0;\r\n                if (sample < -32768)\r\n                    sample = -32768;\r\n                else if (sample > 32767)\r\n                    sample = 32767;\r\n                _writeInt16ToArray(sample, targetArray, offset);\r\n                offset += 2;\r\n            } else if (bitDepth === 32) {\r\n                // This assumes we're going to out 32-float, not 32-bit linear.\r\n                sample = _floatBits(channelData[index]);\r\n                _writeInt32ToArray(sample, targetArray, offset);\r\n                offset += 4;\r\n            } else {\r\n                console.log('Invalid bit depth for PCM encoding.');\r\n                return;\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\r\n// Converts the Blob data to AudioBuffer\r\nasync function _getAudioBuffer(blobData, contextOptions = undefined) {\r\n    let blob = blobData;\r\n\r\n    if (!(blob instanceof Blob)) blob = new Blob([blobData]);\r\n\r\n    const url = URL.createObjectURL(blob);\r\n\r\n    const response = await fetch(url);\r\n\r\n    const arrayBuffer = await response.arrayBuffer();\r\n\r\n    const audioContext = new AudioContext(contextOptions);\r\n\r\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)\r\n\r\n    return audioBuffer;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Blob | Blob[]} blobData - Blob or Blob[] to be converted to audio/wave Blob\r\n * @param {boolean} as32BitFloat - Convert to 16-bit or 32-bit file, default 16-bit\r\n * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n * @returns \r\n */\r\nasync function getWaveBlob(\r\n    blobData, as32BitFloat, contextOptions = undefined\r\n) {\r\n    const audioBuffer = await _getAudioBuffer(blobData, contextOptions);\r\n\r\n    // Encoding setup.\r\n    const frameLength = audioBuffer.length;\r\n    const numberOfChannels = audioBuffer.numberOfChannels;\r\n    const sampleRate = audioBuffer.sampleRate;\r\n    const bitsPerSample = as32BitFloat ? 32 : 16;\r\n    const bytesPerSample = bitsPerSample / 8;\r\n    const byteRate = sampleRate * numberOfChannels * bitsPerSample / 8;\r\n    const blockAlign = numberOfChannels * bitsPerSample / 8;\r\n    const wavDataByteLength = frameLength * numberOfChannels * bytesPerSample;\r\n    const headerByteLength = 44;\r\n    const totalLength = headerByteLength + wavDataByteLength;\r\n    const waveFileData = new Uint8Array(totalLength);\r\n    const subChunk1Size = 16;\r\n    const subChunk2Size = wavDataByteLength;\r\n    const chunkSize = 4 + (8 + subChunk1Size) + (8 + subChunk2Size);\r\n\r\n    _writeStringToArray('RIFF', waveFileData, 0);\r\n    _writeInt32ToArray(chunkSize, waveFileData, 4);\r\n    _writeStringToArray('WAVE', waveFileData, 8);\r\n    _writeStringToArray('fmt ', waveFileData, 12);\r\n\r\n    // SubChunk1Size (4)\r\n    _writeInt32ToArray(subChunk1Size, waveFileData, 16);\r\n    // AudioFormat (2): 3 means 32-bit float, 1 means integer PCM.\r\n    _writeInt16ToArray(as32BitFloat ? 3 : 1, waveFileData, 20);\r\n    // NumChannels (2)\r\n    _writeInt16ToArray(numberOfChannels, waveFileData, 22);\r\n    // SampleRate (4)\r\n    _writeInt32ToArray(sampleRate, waveFileData, 24);\r\n    // ByteRate (4)\r\n    _writeInt32ToArray(byteRate, waveFileData, 28);\r\n    // BlockAlign (2)\r\n    _writeInt16ToArray(blockAlign, waveFileData, 32);\r\n    // BitsPerSample (4)\r\n    _writeInt32ToArray(bitsPerSample, waveFileData, 34);\r\n    _writeStringToArray('data', waveFileData, 36);\r\n    // SubChunk2Size (4)\r\n    _writeInt32ToArray(subChunk2Size, waveFileData, 40);\r\n\r\n    // Write actual audio data starting at offset 44.\r\n    _writeAudioBufferToArray(audioBuffer, waveFileData, 44, bitsPerSample);\r\n\r\n    return new Blob([waveFileData], {\r\n        type: 'audio/wave'\r\n    });\r\n}\r\n\r\nmodule.exports = getWaveBlob;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}