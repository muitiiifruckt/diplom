{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\aayza\\\\OneDrive\\\\\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B\\\\diplom\\\\front\\\\src\\\\components\\\\AudioRecorder.js\",\n  _s = $RefreshSig$();\nimport { useState, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioRecorder = ({\n  onNewAudio\n}) => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [isConverting, setIsConverting] = useState(false);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const sendAudioToServer = async wavBlob => {\n    try {\n      const formData = new FormData();\n      formData.append('audio', wavBlob, 'recording.wav');\n      const response = await fetch('http://localhost:8000/api/upload-audio', {\n        method: 'POST',\n        body: formData\n      });\n      const result = await response.json();\n      console.log('Аудио отправлено:', result);\n    } catch (error) {\n      console.error('Ошибка отправки:', error);\n    } finally {\n      setIsConverting(false);\n    }\n  };\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const options = {\n        audioBitsPerSecond: 128000,\n        mimeType: 'audio/webm'\n      };\n      mediaRecorderRef.current = new MediaRecorder(stream, options);\n      mediaRecorderRef.current.ondataavailable = event => {\n        audioChunksRef.current.push(event.data);\n      };\n      mediaRecorderRef.current.onstop = async () => {\n        setIsConverting(true);\n        try {\n          const webmBlob = new Blob(audioChunksRef.current, {\n            type: 'audio/webm'\n          });\n          const wavBlob = await convertWebmToWav(webmBlob);\n          const audioUrl = URL.createObjectURL(wavBlob);\n          onNewAudio(audioUrl);\n          await sendAudioToServer(wavBlob);\n        } catch (error) {\n          console.error('Ошибка конвертации:', error);\n        } finally {\n          audioChunksRef.current = [];\n          setIsConverting(false);\n        }\n      };\n      mediaRecorderRef.current.start();\n      setIsRecording(true);\n    } catch (err) {\n      console.error('Ошибка доступа к микрофону:', err);\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      setIsRecording(false);\n    }\n  };\n\n  // Конвертация WebM в WAV\n  const convertWebmToWav = async webmBlob => {\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const arrayBuffer = await webmBlob.arrayBuffer();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n    // Кодирование в WAV\n    const wavBuffer = encodeWav(audioBuffer);\n    return new Blob([wavBuffer], {\n      type: 'audio/wav'\n    });\n  };\n\n  // Функция кодирования WAV\n  const encodeWav = audioBuffer => {\n    const numChannels = 1;\n    const sampleRate = 16000;\n    const format = 3; // Float32\n    const bitDepth = 32;\n    const bytesPerSample = bitDepth / 8;\n    const blockAlign = numChannels * bytesPerSample;\n    const buffer = new ArrayBuffer(44 + audioBuffer.length * bytesPerSample);\n    const view = new DataView(buffer);\n\n    // RIFF-заголовок\n    writeString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + audioBuffer.length * bytesPerSample, true);\n    writeString(view, 8, 'WAVE');\n    writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true); // chunk size\n    view.setUint16(20, format, true); // format (3 = float)\n    view.setUint16(22, numChannels, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * blockAlign, true); // byte rate\n    view.setUint16(32, blockAlign, true);\n    view.setUint16(34, bitDepth, true);\n    writeString(view, 36, 'data');\n    view.setUint32(40, audioBuffer.length * bytesPerSample, true);\n\n    // Запись аудиоданных\n    const channels = [];\n    for (let channel = 0; channel < numChannels; channel++) {\n      channels.push(audioBuffer.getChannelData(channel));\n    }\n    let offset = 44;\n    for (let i = 0; i < audioBuffer.length; i++) {\n      for (let channel = 0; channel < numChannels; channel++) {\n        const sample = Math.max(-1, Math.min(1, channels[channel][i]));\n        view.setFloat32(offset, sample, true);\n        offset += 4;\n      }\n    }\n    return buffer;\n  };\n  const writeString = (view, offset, string) => {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-recorder\",\n    children: isRecording ? /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"stop-button\",\n      onClick: stopRecording,\n      disabled: isConverting,\n      children: isConverting ? 'Конвертация...' : 'Остановить запись'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"start-button\",\n      onClick: startRecording,\n      disabled: isConverting,\n      children: isConverting ? 'Обработка...' : 'Записать голосовое сообщение'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 138,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioRecorder, \"8dC4eP0nKSoVxHP4Wndwk4BbjEs=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["useState","useRef","jsxDEV","_jsxDEV","AudioRecorder","onNewAudio","_s","isRecording","setIsRecording","isConverting","setIsConverting","mediaRecorderRef","audioChunksRef","sendAudioToServer","wavBlob","formData","FormData","append","response","fetch","method","body","result","json","console","log","error","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","options","audioBitsPerSecond","mimeType","current","MediaRecorder","ondataavailable","event","push","data","onstop","webmBlob","Blob","type","convertWebmToWav","audioUrl","URL","createObjectURL","start","err","stopRecording","stop","getTracks","forEach","track","audioContext","window","AudioContext","webkitAudioContext","arrayBuffer","audioBuffer","decodeAudioData","wavBuffer","encodeWav","numChannels","sampleRate","format","bitDepth","bytesPerSample","blockAlign","buffer","ArrayBuffer","length","view","DataView","writeString","setUint32","setUint16","channels","channel","getChannelData","offset","i","sample","Math","max","min","setFloat32","string","setUint8","charCodeAt","className","children","onClick","disabled","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/aayza/OneDrive/Рабочий стол/diplom/front/src/components/AudioRecorder.js"],"sourcesContent":["import { useState, useRef } from 'react';\r\n\r\nconst AudioRecorder = ({ onNewAudio }) => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [isConverting, setIsConverting] = useState(false);\r\n  const mediaRecorderRef = useRef(null);\r\n  const audioChunksRef = useRef([]);\r\n\r\n  const sendAudioToServer = async (wavBlob) => {\r\n    try {\r\n      const formData = new FormData();\r\n      formData.append('audio', wavBlob, 'recording.wav');\r\n      \r\n      const response = await fetch('http://localhost:8000/api/upload-audio', {\r\n        method: 'POST',\r\n        body: formData\r\n      });\r\n      \r\n      const result = await response.json();\r\n      console.log('Аудио отправлено:', result);\r\n    } catch (error) {\r\n      console.error('Ошибка отправки:', error);\r\n    } finally {\r\n      setIsConverting(false);\r\n    }\r\n  };\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const options = {\r\n        audioBitsPerSecond: 128000,\r\n        mimeType: 'audio/webm'\r\n      };\r\n      \r\n      mediaRecorderRef.current = new MediaRecorder(stream, options);\r\n      \r\n      mediaRecorderRef.current.ondataavailable = (event) => {\r\n        audioChunksRef.current.push(event.data);\r\n      };\r\n      \r\n      mediaRecorderRef.current.onstop = async () => {\r\n        setIsConverting(true);\r\n        try {\r\n          const webmBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n          const wavBlob = await convertWebmToWav(webmBlob);\r\n          \r\n          const audioUrl = URL.createObjectURL(wavBlob);\r\n          onNewAudio(audioUrl);\r\n          await sendAudioToServer(wavBlob);\r\n        } catch (error) {\r\n          console.error('Ошибка конвертации:', error);\r\n        } finally {\r\n          audioChunksRef.current = [];\r\n          setIsConverting(false);\r\n        }\r\n      };\r\n\r\n      mediaRecorderRef.current.start();\r\n      setIsRecording(true);\r\n    } catch (err) {\r\n      console.error('Ошибка доступа к микрофону:', err);\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorderRef.current && isRecording) {\r\n      mediaRecorderRef.current.stop();\r\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\r\n      setIsRecording(false);\r\n    }\r\n  };\r\n\r\n  // Конвертация WebM в WAV\r\n  const convertWebmToWav = async (webmBlob) => {\r\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n    const arrayBuffer = await webmBlob.arrayBuffer();\r\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n    \r\n    // Кодирование в WAV\r\n    const wavBuffer = encodeWav(audioBuffer);\r\n    return new Blob([wavBuffer], { type: 'audio/wav' });\r\n  };\r\n\r\n  // Функция кодирования WAV\r\n  const encodeWav = (audioBuffer) => {\r\n    const numChannels = 1;\r\n    const sampleRate = 16000;\r\n    const format = 3; // Float32\r\n    const bitDepth = 32;\r\n\r\n    const bytesPerSample = bitDepth / 8;\r\n    const blockAlign = numChannels * bytesPerSample;\r\n    \r\n    const buffer = new ArrayBuffer(44 + audioBuffer.length * bytesPerSample);\r\n    const view = new DataView(buffer);\r\n\r\n    // RIFF-заголовок\r\n    writeString(view, 0, 'RIFF');\r\n    view.setUint32(4, 36 + audioBuffer.length * bytesPerSample, true);\r\n    writeString(view, 8, 'WAVE');\r\n    writeString(view, 12, 'fmt ');\r\n    view.setUint32(16, 16, true); // chunk size\r\n    view.setUint16(20, format, true); // format (3 = float)\r\n    view.setUint16(22, numChannels, true);\r\n    view.setUint32(24, sampleRate, true);\r\n    view.setUint32(28, sampleRate * blockAlign, true); // byte rate\r\n    view.setUint16(32, blockAlign, true);\r\n    view.setUint16(34, bitDepth, true);\r\n    writeString(view, 36, 'data');\r\n    view.setUint32(40, audioBuffer.length * bytesPerSample, true);\r\n\r\n    // Запись аудиоданных\r\n    const channels = [];\r\n    for (let channel = 0; channel < numChannels; channel++) {\r\n      channels.push(audioBuffer.getChannelData(channel));\r\n    }\r\n\r\n    let offset = 44;\r\n    for (let i = 0; i < audioBuffer.length; i++) {\r\n      for (let channel = 0; channel < numChannels; channel++) {\r\n        const sample = Math.max(-1, Math.min(1, channels[channel][i]));\r\n        view.setFloat32(offset, sample, true);\r\n        offset += 4;\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  const writeString = (view, offset, string) => {\r\n    for (let i = 0; i < string.length; i++) {\r\n      view.setUint8(offset + i, string.charCodeAt(i));\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"audio-recorder\">\r\n      {isRecording ? (\r\n        <button className=\"stop-button\" onClick={stopRecording} disabled={isConverting}>\r\n          {isConverting ? 'Конвертация...' : 'Остановить запись'}\r\n        </button>\r\n      ) : (\r\n        <button className=\"start-button\" onClick={startRecording} disabled={isConverting}>\r\n          {isConverting ? 'Обработка...' : 'Записать голосовое сообщение'}\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioRecorder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}