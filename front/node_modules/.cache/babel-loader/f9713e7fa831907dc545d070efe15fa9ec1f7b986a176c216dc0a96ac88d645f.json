{"ast":null,"code":"const getWaveBlob = require(\"./wavBlobUtil\");\nconst downloadWav = require(\"./downloadUtil\");\n\n/** Class Representing a WavRecorder */\nclass WavRecorder {\n  /**\r\n   * @property {MediaRecorder} mediaRecorder - MediaRecorder instance\r\n   */\n  mediaRecorder;\n\n  /**\r\n   * @property {MediaStream} - stream User's MediaStream\r\n   */\n  stream;\n\n  /**\r\n   * @property {Blob} __data - Recorded WEBM data\r\n   */\n  __data;\n\n  /**\r\n   * Access user media from the audio input, will be asking audio permission if not available already\r\n   * @param {MediaTrackConstraints} constraints - MediaTrackConstraints to be applied, if any defaults = { audio: true, video: false }\r\n   * @return - Got User MediaStream or not\r\n   */\n  async start(constraints = {\n    audio: true,\n    video: false\n  }) {\n    if (this.mediaRecorder?.state === \"recording\") return true;\n    const mediaTrackConstraints = constraints || {\n      audio: true,\n      video: false\n    };\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia(mediaTrackConstraints);\n      this.mediaRecorder = new MediaRecorder(this.stream);\n      this.mediaRecorder.ondataavailable = e => this.__data = e.data;\n    } catch (err) {\n      console.error(err);\n      return false;\n    }\n    this.mediaRecorder?.start();\n    return true;\n  }\n\n  /**\r\n   * Stop recording the audio\r\n   * @returns {void}\r\n   */\n  stop() {\n    if (this.mediaRecorder?.state !== \"recording\") return true;\n    this.mediaRecorder.stop();\n    this.mediaRecorder.onstop = () => {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.mediaRecorder = undefined;\n      this.stream = undefined;\n    };\n  }\n\n  /**\r\n   * Download the wav audio file\r\n   * @param {string} filename - Optional name of the file to be downloaded, without extension \r\n   * @param {boolean} as32Bit - Audio required in 32-bit, default is 16-bit.\r\n   * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n   * @returns {void}\r\n   */\n  async download(filename = null, as32Bit = false, contextOptions = undefined) {\n    if (this.__data) return await downloadWav(this.__data, as32Bit, filename, contextOptions);\n  }\n\n  /**\r\n   * Get the recorded wav audio Blob\r\n   * @param {boolean} as32Bit - Get 32-bit audio, default is 16-bit\r\n   * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n   * @returns {void}\r\n   */\n  async getBlob(as32Bit = false, contextOptions = undefined) {\n    if (this.__data) return await getWaveBlob(this.__data, as32Bit, contextOptions);\n  }\n}\nmodule.exports = WavRecorder;","map":{"version":3,"names":["getWaveBlob","require","downloadWav","WavRecorder","mediaRecorder","stream","__data","start","constraints","audio","video","state","mediaTrackConstraints","navigator","mediaDevices","getUserMedia","MediaRecorder","ondataavailable","e","data","err","console","error","stop","onstop","getTracks","forEach","track","undefined","download","filename","as32Bit","contextOptions","getBlob","module","exports"],"sources":["C:/Users/aayza/OneDrive/Рабочий стол/diplom/front/node_modules/webm-to-wav-converter/WavRecorder.js"],"sourcesContent":["const getWaveBlob = require(\"./wavBlobUtil\");\r\nconst downloadWav = require(\"./downloadUtil\");\r\n\r\n/** Class Representing a WavRecorder */\r\nclass WavRecorder {\r\n    /**\r\n     * @property {MediaRecorder} mediaRecorder - MediaRecorder instance\r\n     */\r\n    mediaRecorder;\r\n\r\n    /**\r\n     * @property {MediaStream} - stream User's MediaStream\r\n     */\r\n    stream;\r\n\r\n    /**\r\n     * @property {Blob} __data - Recorded WEBM data\r\n     */\r\n    __data;\r\n\r\n    /**\r\n     * Access user media from the audio input, will be asking audio permission if not available already\r\n     * @param {MediaTrackConstraints} constraints - MediaTrackConstraints to be applied, if any defaults = { audio: true, video: false }\r\n     * @return - Got User MediaStream or not\r\n     */\r\n    async start(constraints = { audio: true, video: false }) {\r\n        if (this.mediaRecorder?.state === \"recording\") return true;\r\n\r\n        const mediaTrackConstraints = constraints || { audio: true, video: false };\r\n\r\n        try {\r\n            this.stream = await navigator.mediaDevices.getUserMedia(mediaTrackConstraints);\r\n\r\n            this.mediaRecorder = new MediaRecorder(this.stream);\r\n\r\n            this.mediaRecorder.ondataavailable = (e) => this.__data = e.data;\r\n        } catch (err) {\r\n            console.error(err);\r\n            return false;\r\n        }\r\n\r\n        this.mediaRecorder?.start();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Stop recording the audio\r\n     * @returns {void}\r\n     */\r\n    stop() {\r\n        if (this.mediaRecorder?.state !== \"recording\") return true;\r\n\r\n        this.mediaRecorder.stop();\r\n        this.mediaRecorder.onstop = () => {\r\n            this.stream.getTracks().forEach(track => track.stop());\r\n            this.mediaRecorder = undefined;\r\n            this.stream = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Download the wav audio file\r\n     * @param {string} filename - Optional name of the file to be downloaded, without extension \r\n     * @param {boolean} as32Bit - Audio required in 32-bit, default is 16-bit.\r\n     * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n     * @returns {void}\r\n     */\r\n    async download(\r\n        filename = null, as32Bit = false, contextOptions = undefined\r\n    ) {\r\n        if (this.__data) return await downloadWav(this.__data, as32Bit, filename, contextOptions);\r\n    }\r\n\r\n    /**\r\n     * Get the recorded wav audio Blob\r\n     * @param {boolean} as32Bit - Get 32-bit audio, default is 16-bit\r\n     * @param {AudioContextOptions} contextOptions - optiosn needs to be used for encoding\r\n     * @returns {void}\r\n     */\r\n    async getBlob(as32Bit = false, contextOptions = undefined) {\r\n        if (this.__data) return await getWaveBlob(this.__data, as32Bit, contextOptions);\r\n    }\r\n}\r\n\r\nmodule.exports = WavRecorder;"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;;AAE7C;AACA,MAAME,WAAW,CAAC;EACd;AACJ;AACA;EACIC,aAAa;;EAEb;AACJ;AACA;EACIC,MAAM;;EAEN;AACJ;AACA;EACIC,MAAM;;EAEN;AACJ;AACA;AACA;AACA;EACI,MAAMC,KAAKA,CAACC,WAAW,GAAG;IAAEC,KAAK,EAAE,IAAI;IAAEC,KAAK,EAAE;EAAM,CAAC,EAAE;IACrD,IAAI,IAAI,CAACN,aAAa,EAAEO,KAAK,KAAK,WAAW,EAAE,OAAO,IAAI;IAE1D,MAAMC,qBAAqB,GAAGJ,WAAW,IAAI;MAAEC,KAAK,EAAE,IAAI;MAAEC,KAAK,EAAE;IAAM,CAAC;IAE1E,IAAI;MACA,IAAI,CAACL,MAAM,GAAG,MAAMQ,SAAS,CAACC,YAAY,CAACC,YAAY,CAACH,qBAAqB,CAAC;MAE9E,IAAI,CAACR,aAAa,GAAG,IAAIY,aAAa,CAAC,IAAI,CAACX,MAAM,CAAC;MAEnD,IAAI,CAACD,aAAa,CAACa,eAAe,GAAIC,CAAC,IAAK,IAAI,CAACZ,MAAM,GAAGY,CAAC,CAACC,IAAI;IACpE,CAAC,CAAC,OAAOC,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;MAClB,OAAO,KAAK;IAChB;IAEA,IAAI,CAAChB,aAAa,EAAEG,KAAK,CAAC,CAAC;IAC3B,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;EACIgB,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACnB,aAAa,EAAEO,KAAK,KAAK,WAAW,EAAE,OAAO,IAAI;IAE1D,IAAI,CAACP,aAAa,CAACmB,IAAI,CAAC,CAAC;IACzB,IAAI,CAACnB,aAAa,CAACoB,MAAM,GAAG,MAAM;MAC9B,IAAI,CAACnB,MAAM,CAACoB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACJ,IAAI,CAAC,CAAC,CAAC;MACtD,IAAI,CAACnB,aAAa,GAAGwB,SAAS;MAC9B,IAAI,CAACvB,MAAM,GAAGuB,SAAS;IAC3B,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,QAAQA,CACVC,QAAQ,GAAG,IAAI,EAAEC,OAAO,GAAG,KAAK,EAAEC,cAAc,GAAGJ,SAAS,EAC9D;IACE,IAAI,IAAI,CAACtB,MAAM,EAAE,OAAO,MAAMJ,WAAW,CAAC,IAAI,CAACI,MAAM,EAAEyB,OAAO,EAAED,QAAQ,EAAEE,cAAc,CAAC;EAC7F;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMC,OAAOA,CAACF,OAAO,GAAG,KAAK,EAAEC,cAAc,GAAGJ,SAAS,EAAE;IACvD,IAAI,IAAI,CAACtB,MAAM,EAAE,OAAO,MAAMN,WAAW,CAAC,IAAI,CAACM,MAAM,EAAEyB,OAAO,EAAEC,cAAc,CAAC;EACnF;AACJ;AAEAE,MAAM,CAACC,OAAO,GAAGhC,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}